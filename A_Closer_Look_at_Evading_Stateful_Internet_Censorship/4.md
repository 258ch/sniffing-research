## 四、GFW行为的演变  

正如§3中所提到的，即使我们消除了中间设备，服务器实现和网络动态的影响，也具有高故障率。 为了理解根本原因，我们仔细研究并认为这是由于演变的GFW行为破坏了许多先前的假设。 根据我们的测量结果，我们假设这些新行为如下。 为了验证这些假设，我们在第7节中设计并广泛评估了新的绕过策略。

先前假设1：GFW仅在看到SYN数据包时才创建TCB。 

为了测试这个假设，我们使用了我们控制下的客户端和服务器对，并执行部分TCP 3路握手（例如，有意省略SYN，SYN / ACK和/或ACK），然后执行带有敏感关键字的HTTP请求。 如果在GFW上创建了正确的TCB，则HTTP请求将触发来自它的TCP重置数据包。 首先，我们的结果证实GFW在看到[...]中描述的SYN数据包时仍会创建TCB。 第二个也是更有趣的是，我们发现GFW在没有看到SYN数据包而是SYN / ACK数据包时也会创建一个TCB。 我们推测GFW已经发展到将此功能用于抵消SYN数据包丢失。 鉴于这些，我们假设GFW表现出以下新行为。

假设的新行为1：GFW不仅在接收到SYN数据包时，还在SYN / ACK数据包时创建了TCB。 

先前假设2：GFW使用第一个SYN数据包中的序列号来创建TCB，并在TCB的生命周期内忽略稍后的SYN数据包。

该假设基于GFW模仿正常TCP实现的基本原理。 我们仔细观察发现它没有。 从第3节中的结果可以看出，在大多数情况下，使用SYN插入数据包创建TCB失败了。 这导致我们重新审视这个案例。 我们发送多个SYN数据包，其中只有一个具有“真实”序列号，然后发送敏感的HTTP请求。 但是，无论我们放置“真正的”SYN数据包，GFW总能检测到后来敏感的关键字。 我们假设这可能是由于以下三个原因中的任何一个：

（1）GFW建立多个TCB，每个SYN包一个; （2）GFW进入“无状态模式”，在其中检查每个单独的数据包（并检查敏感的关键字）而不是首先重新组装数据; （3）GFW使用HTTP请求中的序列号重新同步其TCB。

为了检查（1），我们将HTTP请求中的序列号设置为SYN封包中的序列号的“窗口外”值; 但是，我们发现GFW仍然可以检测到关键字。 为了检验（2），我们将敏感关键字分成两半，每个关键字本身都不是敏感关键字; 但是，我们发现GFW仍然可以检测到它。 对于（3），在发送HTTP请求之前，我们发送一些带有“假”序列号的随机数据，然后我们发送带有“真”序列号的HTTP请求; 在这种情况下，GFW无法检测到它。 这表明GFW将其TCB与随机数据中的序列号重新同步，因此，由于其窗口外序列号，忽略了后来的HTTP请求。 这验证了假设（3）GFW在看到多个SYN封包时进入“重新同步状态”。 我们在第7节进一步验证了这一点。

除了多个SYN数据包之外，我们发现多个SYN / ACK数据包或具有错误确认号的SYN / ACK数据包也会导致GFW进入重新同步状态。

接下来，我们尝试找出“GFW在重新同步状态下使用哪个数据包重新同步其TCB。”从上一个实验中，我们了解到GFW使用从客户端到服务器的数据包重新同步。 因此，我们尝试使用从服务器到客户端的数据包; 此外，我们在两个方向上尝试没有数据的纯ACK数据包。 我们发现这些数据包都不会影响GFW。 但是，我们发现从服务器到客户端的SYN / ACK数据包可以导致重新同步。 我们承认我们发现的案例可能不完整，但很难列举这些案例的详尽集合。 然而，我们的测量结果使我们更好地理解GFW行为，而不是现在的情况，并引导我们进入以下新假设。

假设的新行为2：GFW进入我们称之为“重新同步状态”的状态。以下三种情况下，它使用从服务器到客户端的下一个SYN / ACK数据包中的信息或从客户端到服务器的数据包重新同步其TCB：（a）它看到来自客户端的多个SYN数据包，（b）它看到来自服务器端的多个SYN / ACK数据包，或者（c）它看到一个SYN / ACK数据包，确认号不同于来自SYN数据包中的序列号。

先前的假设3：当GFW看到RST，RST / ACK或FIN数据包时，它会拆除TCB。
