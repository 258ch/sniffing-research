## 四、GFW行为的演变  

正如§3中所提到的，即使我们消除了中间设备，服务器实现和网络动态的影响，也具有高故障率。 为了理解根本原因，我们仔细研究并认为这是由于演变的GFW行为破坏了许多先前的假设。 根据我们的测量结果，我们假设这些新行为如下。 为了验证这些假设，我们在第7节中设计并广泛评估了新的绕过策略。

先前假设1：GFW仅在看到SYN数据包时才创建TCB。 

为了测试这个假设，我们使用了我们控制下的客户端和服务器对，并执行部分TCP 3路握手（例如，有意省略SYN，SYN / ACK和/或ACK），然后执行带有敏感关键字的HTTP请求。 如果在GFW上创建了正确的TCB，则HTTP请求将触发来自它的TCP重置数据包。 首先，我们的结果证实GFW在看到[...]中描述的SYN数据包时仍会创建TCB。 第二个也是更有趣的是，我们发现GFW在没有看到SYN数据包而是SYN / ACK数据包时也会创建一个TCB。 我们推测GFW已经发展到将此功能用于抵消SYN数据包丢失。 鉴于这些，我们假设GFW表现出以下新行为。

假设的新行为1：GFW不仅在接收到SYN数据包时，还在SYN / ACK数据包时创建了TCB。 

先前假设2：GFW使用第一个SYN数据包中的序列号来创建TCB，并在TCB的生命周期内忽略稍后的SYN数据包。

该假设基于GFW模仿正常TCP实现的基本原理。 我们仔细观察发现它没有。 从第3节中的结果可以看出，在大多数情况下，使用SYN插入数据包创建TCB失败了。 这导致我们重新审视这个案例。 我们发送多个SYN数据包，其中只有一个具有“真实”序列号，然后发送敏感的HTTP请求。 但是，无论我们放置“真正的”SYN数据包，GFW总能检测到后来敏感的关键字。 我们假设这可能是由于以下三个原因中的任何一个：

（1）GFW建立多个TCB，每个SYN包一个; （2）GFW进入“无状态模式”，在其中检查每个单独的数据包（并检查敏感的关键字）而不是首先重新组装数据; （3）GFW使用HTTP请求中的序列号重新同步其TCB。

为了检查（1），我们将HTTP请求中的序列号设置为SYN封包中的序列号的“窗口外”值; 但是，我们发现GFW仍然可以检测到关键字。 为了检验（2），我们将敏感关键字分成两半，每个关键字本身都不是敏感关键字; 但是，我们发现GFW仍然可以检测到它。 对于（3），在发送HTTP请求之前，我们发送一些带有“假”序列号的随机数据，然后我们发送带有“真”序列号的HTTP请求; 在这种情况下，GFW无法检测到它。 这表明GFW将其TCB与随机数据中的序列号重新同步，因此，由于其窗口外序列号，忽略了后来的HTTP请求。 这验证了假设（3）GFW在看到多个SYN封包时进入“重新同步状态”。 我们在第7节进一步验证了这一点。

除了多个SYN数据包之外，我们发现多个SYN / ACK数据包或具有错误确认号的SYN / ACK数据包也会导致GFW进入重新同步状态。

接下来，我们尝试找出“GFW在重新同步状态下使用哪个数据包重新同步其TCB。”从上一个实验中，我们了解到GFW使用从客户端到服务器的数据包重新同步。 因此，我们尝试使用从服务器到客户端的数据包; 此外，我们在两个方向上尝试没有数据的纯ACK数据包。 我们发现这些数据包都不会影响GFW。 但是，我们发现从服务器到客户端的SYN / ACK数据包可以导致重新同步。 我们承认我们发现的案例可能不完整，但很难列举这些案例的详尽集合。 然而，我们的测量结果使我们更好地理解GFW行为，而不是现在的情况，并引导我们进入以下新假设。

假设的新行为2：GFW进入我们称之为“重新同步状态”的状态。以下三种情况下，它使用从服务器到客户端的下一个SYN / ACK数据包中的信息或从客户端到服务器的数据包重新同步其TCB：（a）它看到来自客户端的多个SYN数据包，（b）它看到来自服务器端的多个SYN / ACK数据包，或者（c）它看到一个SYN / ACK数据包，确认号不同于来自SYN数据包中的序列号。

先前的假设3：当GFW看到RST，RST / ACK或FIN数据包时，它会拆除TCB。

§3中的结果表明，演进的GFW通常不会仅仅在看到FIN数据包时拆除TCB。与此同时，我们还使用RST和RST / ACK插入数据包观察到高于20％的高失败率。仔细观察表明，这可能是由于“假设的新行为2”。更具体地说，我们发现当GFW处于新发现的“重新同步状态”时，其TCB有时不能用RST或RST /ACK数据包来拆除。为了验证这一点，我们使用上述技术之一强制GFW进入重新同步状态，然后立即发送RST数据包和带有敏感关键字的HTTP请求。但是，GFW有时仍然可以检测到它。我们使用多对客户端和服务器在不同时间重复该实验，并且发现在不同时间的不同测量之间存在不一致。总体成功率大约为80％，对于特定的客户端 - 服务器对，GFW的行为通常在某个时期内是一致的（尽管并非总是跨时期）。我们目前无法发现背后的明显原因;我们推测这是由于所遇到的GFW类型的不同，以及不同GFW实例和中间设备之间的交互的复杂性。我们在第8节进一步讨论。

此外，我们进行了大量测量，其中我们在3次握手的SYN / ACK和ACK数据包之间，以及3次握手之后发送了RST数据包。 我们发现在这两种情况下，TCB有时不会被拆除，但RST数据包导致GFW进入重新同步状态; 此外，我们发现前一种情况更常发生（差异的确切原因仍然未知）。 这些观察结果导致了以下新的假设。

假设的新行为3：在接收到RST或RST / ACK封包时，GFW可以进入重新同步状态而不是拆除TCB。
